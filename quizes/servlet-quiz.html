<!DOCTYPE html>
<html>
<head>
    <title> Servlet Quiz</title>
</head>
<body>
<ol>
    <li><p >What is the difference between a web server and a web container?</p>
        <p >  
            Web server is the network address in which used to send requests and then procceded,
	    web server handles Http Requests and prepares the http response, web server is the middle
	    layer between the client and the web container.
	    Web container contains JSP and servlet files and is responsible for managing them,
	    and executing the correct files based on the request routed from the web server.
	 </p>
    </li>

    <li><p >What is a servlet?</p>
	    <p>
		    Is like a web server but with extended functionality,
            Java Servlets are server-side Java program modules that process and answer client requests and implement the servlet interface.
            It helps in enhancing Web server functionality with minimal overhead, maintenance and support.
            A servlet acts as an intermediary between the client and the server. As servlet modules run on the server, they can receive and respond to requests made by the client.
	    </p>
    </li>
    <li><p >How do web servers and web containers interact with servlets?
    </p>
        <p >Whenever a client sends a request to the server, the Application server passes the request to the Web container.
            The Web container checks whether an instance of the requested servlet exists.
            If the servlet instance exists then the Web container delegates the request to the servlet, which process the client request and sends back the response.
            In case the servlet instance does not exist, the Web container locates and loads the servlet class.
            The Web container then creates an instance of the servlet and initializes it. The servlet instance starts processing the request after initialization.
            The Web container passes the response generated by the servlet to the client.
            The Web container manages a servlet by invoking various life cycle methods. These methods are defined in the Servlet API.
	</p>
    <li><p >Who creates request objects?
    </p>
		    <p> Client makes the request, the server proccess the request, invokes service method and service creates the
			    request object.
		    </p>
    </li>
    <li><p >What are the states in the servlet lifecycle?</p>
	    <p> init(), service() and destroy(). </p>
    </li>
    <li><p >Who calls init and when?</p>
        <p >
		On the first request in the service method.
        </p>
    </li>
    <li><p >Which of init, service, and doGet should you override?</p>
        <p >
            init() we can Possibly override If you have initialization code then you will override the init() method
            service() Very unlikely. 
	    We should NOT override the service() method.
            doGet() and doPost()- we should Always override at least ONE of doGet() or doPost()
            You can call each other to cover both options, for example doGet() could call doPost() method which has the code
        </p>
    </li>

    <li><p >In what sense are servlets multi-threaded?</p>
        <p >
            multiple requests to the same servlet may be executed at the same time.
            Therefore, you need to take concurrency into consideration when you implement your servlet.
            Servlets are intrinsically multithreaded.This means a single instance can be accessed by more than one thread.
        </p>

    </li>
    <li><p >What are the implications of this for servlet instance variables? </p>
        <p >
            SingleThreadModel is an empty interface that tells the web server to only send one client request at a time into your servlet.
            From the JavaDoc: If the target servlet is flagged with this interface, the servlet programmer is guaranteed that no two threads will execute concurrently the service method of that servlet.
            This guarantee is ensured by maintaining a pool of servlet instances for each such servlet, and dispatching each service call to a free servlet.
            In essence, if the servlet implements this interface, the servlet will be thread 
            Note that this is not an ideal solution, since performance may suffer (depending on the size of the instance pool), plus it's more difficult to share data across instances than within a single instance.
        </p>
    </li>
</ol>
</body>
</html>
